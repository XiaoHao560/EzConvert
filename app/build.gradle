plugins {
    id 'com.android.application'
}

def isRunningOnGithub = System.getenv('GITHUB_ACTIONS') == 'true'

println "=== Build environmental information ==="
println "运行在 GitHub Actions: $isRunningOnGithub"

// 读取本地密钥配置
def getLocalKeystoreConfig() {
    def config = [:]
    def keystorePropertiesFile = rootProject.file('key/keystore.properties')
    
    if (keystorePropertiesFile.exists()) {
        try {
            def properties = new Properties()
            properties.load(new FileInputStream(keystorePropertiesFile))
            
            config.fileName = properties.getProperty('storeFile', '')
            config.storePassword = properties.getProperty('storePassword', '')
            config.keyAlias = properties.getProperty('keyAlias', '')
            config.keyPassword = properties.getProperty('keyPassword', '')
            
            if (config.fileName && config.storePassword && config.keyAlias && config.keyPassword) {
                def keystoreFile = rootProject.file("key/${config.fileName}")
                config.fileExists = keystoreFile.exists()
                if (config.fileExists) {
                    println "✓ Local key configuration has been loaded"
                    return config
                }
            }
        } catch (Exception e) {
            println "✗ Loading local key configuration failed: ${e.message}"
        }
    }
    return null
}

def getGitVersionCode() {
    try {
        def commitCount = getCmdOutput("git rev-list --count HEAD").toInteger()
        def timestamp = new java.text.SimpleDateFormat("yyMMdd").format(new Date()).toInteger()
        def versionCode = timestamp * 1000 + (commitCount % 1000)
        
        println "=== VersionCode Generation ==="
        println "Build Date: ${new Date()}"
        println "Git Commit Count: $commitCount"
        println "Timestamp (YYMMDD): $timestamp"
        println "Generated VersionCode: $versionCode"
        
        return versionCode
        
    } catch (Exception e) {
        println "Warning: Could not get git version code: ${e.message}"
        def fallback = new java.text.SimpleDateFormat("yyMMddHH").format(new Date()).toInteger()
        println "Using fallback version code: $fallback"
        return fallback
    }
}

def getGitVersionName() {
    try {
        def describe = getCmdOutput("git describe --tags --long --always")
        def commitHash = getCmdOutput("git rev-parse --short HEAD")
        
        println "=== VersionName Generation ==="
        println "Git Describe: $describe"
        println "Commit Hash: $commitHash"
        
        def branchName = getCmdOutput("git rev-parse --abbrev-ref HEAD")
        def isDetachedHEAD = (branchName == "HEAD")
        
        if (isDetachedHEAD) {
            def githubRef = System.getenv("GITHUB_REF")
            println "GITHUB_REF: $githubRef"
            
            if (githubRef?.startsWith("refs/tags/")) {
                println "Tag build detected, using tag-based versioning"
                return extractVersionFromTag(describe)
            } else if (githubRef?.startsWith("refs/heads/")) {
                branchName = githubRef.substring(11)
                println "Recovered branch name from GITHUB_REF: $branchName"
            } else if (githubRef?.startsWith("refs/pull/")) {
                def prNumber = githubRef.split("/")[2]
                branchName = "pr-$prNumber"
                println "PR build detected, using branch: $branchName"
            } else {
                branchName = "detached-${commitHash}"
            }
        }
        
        def isMainBranch = isMainBranch(branchName)
        
        println "Final Branch: $branchName"
        println "Is Main Branch: $isMainBranch"
        
        if (describe.contains("0.1.7-alpha")) {
            return isMainBranch ? "0.2.0.alpha" : "0.2.0.alpha-${getSafeBranchName(branchName)}"
        }
        
        if (describe.matches("^v?\\d+(\\.\\d+)*\$")) {
            def version = describe.replaceAll("^v", "")
            return isMainBranch ? version : "${version}-${getSafeBranchName(branchName)}"
        }
        else if (describe.matches(".*-\\d+-g[0-9a-f]+\$")) {
            def parts = describe.split("-")
            def baseVersion = parts[0].replaceAll("^v", "")
            def commitsAfterTag = parts[1]
            
            if (commitsAfterTag == "0") {
                return isMainBranch ? baseVersion : "${baseVersion}-${getSafeBranchName(branchName)}"
            }
            
            return isMainBranch ? "${baseVersion}.${commitsAfterTag}" : "${baseVersion}.${commitsAfterTag}-${getSafeBranchName(branchName)}"
        }
        else {
            return isMainBranch ? "0.2.0-${commitHash}" : "0.2.0-${getSafeBranchName(branchName)}"
        }
        
    } catch (Exception e) {
        println "Error getting git version name: ${e.message}"
        return "0.2.0-dev"
    }
}

def extractVersionFromTag(describe) {
    if (describe.matches("^v?\\d+(\\.\\d+)*\$")) {
        return describe.replaceAll("^v", "")
    }
    else if (describe.matches(".*-\\d+-g[0-9a-f]+\$")) {
        def parts = describe.split("-")
        def baseVersion = parts[0].replaceAll("^v", "")
        def commitsAfterTag = parts[1]
        
        if (commitsAfterTag == "0") {
            return baseVersion
        }
        
        return "${baseVersion}.${commitsAfterTag}"
    }
    else {
        return describe
    }
}

def isMainBranch(branchName) {
    return branchName == "main" || branchName == "master" || 
           branchName.startsWith("refs/tags/") ||
           branchName.startsWith("pr-")
}

def getSafeBranchName(branchName) {
    return branchName
        .replaceAll("[^a-zA-Z0-9.-]", "-")
        .replaceAll("^-+|-+\$", "")
        .replaceAll("-+", "-")
        .toLowerCase()
        .take(15)
}

def getCmdOutput(command) {
    def stdout = new ByteArrayOutputStream()
    try {
        exec {
            commandLine command.split(' ')
            standardOutput = stdout
        }
        return stdout.toString().trim()
    } catch (Exception e) {
        throw e
    }
}

task printVersionInfo {
    doLast {
        println "=== Project Version Information ==="
        println "Version Code: ${getGitVersionCode()}"
        println "Version Name: ${getGitVersionName()}"
        
        try {
            def branchName = getCmdOutput("git rev-parse --abbrev-ref HEAD")
            def commitHash = getCmdOutput("git rev-parse --short HEAD")
            def describe = getCmdOutput("git describe --tags --long --always")
            
            println "Git Branch: $branchName"
            println "Git Commit: $commitHash"
            println "Git Describe: $describe"
        } catch (Exception e) {
            println "Cannot get Git information: ${e.message}"
        }
    }
}

task checkSigningConfig {
    doLast {
        println "=== Signature configuration check ==="
        println "Current environment: ${isRunningOnGithub ? 'GitHub Actions' : 'local'}"
        if (android.signingConfigs.hasProperty('release')) {
            println "Release signature file: ${android.signingConfigs.release.storeFile}"
            println "Release signature file exists: ${android.signingConfigs.release.storeFile.exists()}"
        }
    }
}

android {
    namespace 'com.tech.ezconvert'
    compileSdk 34

    defaultConfig {
        applicationId "com.tech.ezconvert"
        minSdk 24
        targetSdk 33
        
        versionCode getGitVersionCode()
        versionName getGitVersionName()
        
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables.useSupportLibrary = true
        
        externalNativeBuild {
            cmake {
                cppFlags "-std=c++17"
                arguments "-DANDROID_STL=c++_shared"
            }
        }
        
        ndk {
            abiFilters 'arm64-v8a'
        }
    }
    
    // 签名配置
    signingConfigs {
        
        release {
            // GitHub Actions 环境
            if (isRunningOnGithub) {
                println "GitHub Actions environment detected, using CI/CD signing configuration"
                storeFile file(System.getenv("KEYSTORE_FILE") ?: "debug.keystore")
                storePassword System.getenv("KEYSTORE_PASSWORD")
                keyAlias System.getenv("KEY_ALIAS")
                keyPassword System.getenv("KEY_PASSWORD")
                
                enableV1Signing true
                enableV2Signing true
                enableV3Signing true
                enableV4Signing false
            }
            // 本地环境
            else {
                def localConfig = getLocalKeystoreConfig()
                if (localConfig != null) {
                    println "Release build: use local key configuration"
                    storeFile file(rootProject.file("key/${localConfig.fileName}"))
                    storePassword localConfig.storePassword
                    keyAlias localConfig.keyAlias
                    keyPassword localConfig.keyPassword
                    
                    enableV1Signing true
                    enableV2Signing true
                    enableV3Signing true
                    enableV4Signing false
                } else {
                    // 如果没有配置本地密钥，就不配置release签名，构建会失败
                    println "Error: The local build Release requires the signing configuration in the key folder"
                    println "Please create key/keystore.properties and configure the signing information"
                    
                    // 这里抛出异常，让构建失败
                    throw new GradleException("No local signing configuration found. Please create the key folder and configure keystore.properties")
                }
            }
        }
    }
    
    applicationVariants.all { variant ->
        variant.outputs.all {
            def appName = "EzConvert"
            def buildType = variant.buildType.name
            def versionName = variant.versionName
            def versionCode = variant.versionCode
            
            def suffix = buildType == "debug" ? "-debug" : ""
            
            outputFileName = "${appName}${suffix}-v${versionName}(${versionCode}).apk"
        }
    }
    
    buildTypes {
        release {
            if (signingConfigs.hasProperty('release')) {
                signingConfig signingConfigs.release
            }
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            minifyEnabled false
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    
    externalNativeBuild {
        cmake {
            path file('src/main/cpp/CMakeLists.txt')
            version "3.22.1"
        }
    }
    
    ndkVersion "24.0.8215888"
    
    packagingOptions {
        pickFirst '**/libc++_shared.so'
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.12.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    implementation 'androidx.core:core-splashscreen:1.0.1'
    
    implementation 'com.arthenica:ffmpeg-kit-full-gpl:6.0-2'
    
    implementation 'io.noties.markwon:core:4.6.2'
    implementation 'io.noties.markwon:ext-tables:4.6.2'
    implementation 'io.noties.markwon:ext-strikethrough:4.6.2'
    implementation 'io.noties.markwon:linkify:4.6.2'
    implementation 'io.noties.markwon:html:4.6.2'
    implementation 'io.noties.markwon:image:4.6.2'

    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}

preBuild {
    doFirst {
        println "Build Info: ${getGitVersionName()} (${getGitVersionCode()})"
        println "Build type: ${gradle.startParameter.taskNames.find { it.contains('Release') } ? 'Release' : 'Debug'}"
    }
}